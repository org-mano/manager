#########
# Copyright (c) 2016 GigaSpaces Technologies Ltd. All rights reserved
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
#  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  * See the License for the specific language governing permissions and
#  * limitations under the License.

from uuid import uuid4
from datetime import datetime
from collections import namedtuple

from flask import current_app
from flask_security.utils import encrypt_password

from .ldap import get_ldappy

from manager_rest.storage import user_datastore
from manager_rest.constants import USER_ROLE
from manager_rest.app_logging import raise_unauthorized_user_error
from manager_rest.storage import get_storage_manager
from manager_rest.storage.models import Group


Authorization = namedtuple('Authorization', 'username password')


class LdapAuthentication(object):
    def __init__(self):
        self._ldappy = None

    def configure_ldap(self):
        """Set the Ldappy instance; *must* be called after the configuration
        is loaded
        """
        self._ldappy = get_ldappy()
        if self._ldappy:
            return self
        else:
            return None

    def authenticate_user(self, username, password):
        if not self._ldappy.authenticate(username, password):
            raise_unauthorized_user_error(
                'LDAP authentication has failed for '
                '<User username=`{0}`>'.format(username)
            )

    def update_user(self, user):
        # Reloading the user from the datastore, because the current user
        # object is detached from a session
        username = user.username
        user = user_datastore.get_user(username)

        ldap_user = self._ldappy.user_objects.get(name=username)
        ldap_groups = self._get_user_ldap_groups(ldap_user.groups())
        groups_to_add = self._only_in_first_collection(ldap_groups,
                                                       user.groups)
        groups_to_remove = self._only_in_first_collection(user.groups,
                                                          ldap_groups)

        for group in groups_to_add:
            user.groups.append(group)
        for group in groups_to_remove:
            user.groups.remove(group)
        return user

    @staticmethod
    def _only_in_first_collection(groups_a, groups_b):
        # Will preform groups_a - groups_b according to group name
        group_b_names = [group.name for group in groups_b]
        return [group for group in groups_a if group.name not in group_b_names]

    def create_user(self, username):
        """Create in the DB and return a new user using LDAP data
        """
        ldap_user = self._ldappy.user_objects.get(name=username)
        user_data = ldap_user.pretty_data()

        # Getting the first element because ldappy always returns lists
        email = user_data.get('mail')[0]
        first_name = user_data.get('first_name')[0]
        last_name = user_data.get('last_name')[0]

        default_role = user_datastore.find_role(USER_ROLE)

        # Generating some random password - to be used only in tokens
        generated_password = str(uuid4().fields[-1])
        user = user_datastore.create_user(
                username=username,
                password=encrypt_password(generated_password),
                email=email,
                first_name=first_name,
                last_name=last_name,
                created_at=datetime.now(),
                roles=[default_role]
        )
        user_datastore.commit()
        current_app.extensions['security'].login_manager.reload_user(user)

        user.groups = self._get_user_ldap_groups(ldap_user.groups())
        return user

    @staticmethod
    def _get_user_ldap_groups(ldap_groups):
        storage_manager = get_storage_manager()
        ldap_dns = [group.distinguished_name for group in ldap_groups]
        return storage_manager.list(Group, filters={'ldap_dn': ldap_dns}).items


ldap_authenticator = LdapAuthentication()

# Needs to be called only after the configuration was loaded
configure_ldap = ldap_authenticator.configure_ldap
