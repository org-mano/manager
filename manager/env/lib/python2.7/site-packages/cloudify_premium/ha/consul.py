########
# Copyright (c) 2016 GigaSpaces Technologies Ltd. All rights reserved
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
#    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#    * See the License for the specific language governing permissions and
#    * limitations under the License.


from __future__ import absolute_import

import os
import pwd
import grp
import json
import time
import shutil
import logging
import requests

from consul import ConsulException
from consul.std import Consul as ConsulClientBase, HTTPClient as ConsulHTTPBase

from cloudify_premium.ha import ssl, systemd, node_status, sudo, utils

try:
    from requests.packages.urllib3.exceptions import (InsecurePlatformWarning,
                                                      SNIMissingWarning)
except ImportError:
    # those might not be available if we're not based on urllib3,
    # which happens eg. in unittests
    pass
else:
    # unfortunate, but we're tied to python 2.7.5 on centos7
    requests.packages.urllib3.disable_warnings(SNIMissingWarning)
    requests.packages.urllib3.disable_warnings(InsecurePlatformWarning)

logger = logging.getLogger(__name__)

CONSUL_CONFIG_PATH = '/etc/consul.d/config.json'
# cert & key used by the consul server for tls communication and authenticating
# to other consul nodes
CONSUL_SERVER_CERT = '/etc/cloudify/ssl/consul_server.crt'
CONSUL_SERVER_KEY = '/etc/cloudify/ssl/consul_server.key'

# cert & key used by the consul HTTPS API client for authenticating with consul
CONSUL_CLIENT_CERT = '/etc/cloudify/ssl/consul_client.crt'
CONSUL_CLIENT_KEY = '/etc/cloudify/ssl/consul_client.key'

# cert & key used by consul for verifying clients (both HTTPS and internal)
CONSUL_CA_CERT = '/etc/cloudify/ssl/consul_ca.crt'
CONSUL_CA_KEY = '/etc/cloudify/ssl/consul_ca.key'

CONSUL_OS_USERNAME = 'cfyuser_consul'


class Consul(systemd.SystemdManaged):
    """The consul service running on the manager"""
    user = CONSUL_OS_USERNAME
    unit_source = 'resources/cloudify-consul.service'
    service_name = 'consul'
    data_dir = '/opt/consul/data'

    def prepare_settings(self, node_name, host_ip, credentials,
                         join_addrs=None, bootstrap_cluster=False, **kwargs):
        if not bootstrap_cluster and not join_addrs:
            raise ValueError('--join-addrs must be specified when '
                             'bootstrap_cluster is False')
        config = {
            'rejoin_after_leave': True,
            'server': True,
            'ui': True,
            'advertise_addr': host_ip,
            'client_addr': '0.0.0.0',
            'data_dir': self.data_dir,
            'node_name': node_name,
            'bootstrap': bootstrap_cluster,
            'cert_file': CONSUL_SERVER_CERT,
            'key_file': CONSUL_SERVER_KEY,
            'ca_file': CONSUL_CA_CERT,
            'verify_incoming': True,
            'verify_outgoing': True,
            'ports': {
                'http': -1,
                'https': 8500
            }
        }
        if credentials.get('encryption_key'):
            config['encrypt'] = credentials['encryption_key']
        if join_addrs:
            config['retry_join'] = join_addrs

        logger.debug('Writing consul config: %s', config)
        self.update_settings(**config)

    def get_settings(self):
        try:
            with open(CONSUL_CONFIG_PATH) as f:
                return json.load(f)
        except (IOError, ValueError):
            return {}

    def update_settings(self, **kwargs):
        settings = self.get_settings()
        settings.update(kwargs)

        with open(CONSUL_CONFIG_PATH, 'w') as f:
            json.dump(settings, f, indent=4, sort_keys=True)

    def disable_bootstrap(self):
        """Set the bootstrap consul settings to false and reload consul.

        When we first start consul in the cluster, it needs the bootstrap flag;
        this is disabled for performance reasons (faster cluster re-join)
        when a second node joins the cluster.
        """
        old_settings = self.get_settings()
        if old_settings.get('bootstrap'):
            self.update_settings(bootstrap=False)
            sudo.run(['reload_consul'])

    def force_peers(self, peers):
        command = ['consul_peers', '--data-dir', self.data_dir] + peers
        sudo.run(command)

    def clear(self):
        """Remove the data directory"""
        shutil.rmtree(self.data_dir)


class ConsulWatcher(systemd.SystemdManaged):
    unit_source = 'resources/cloudify-consul-watcher.service'
    service_name = 'consul-watcher'
    user = utils.CLOUDIFY_USER


class ConsulRecoveryWatcher(systemd.SystemdManaged):
    unit_source = 'resources/cloudify-consul-recovery-watcher.service'
    service_name = 'consul-recovery-watcher'
    user = utils.CLOUDIFY_USER


def configure(node_name, host_ip, bootstrap_cluster=False,
              credentials=None, **kwargs):
    if credentials is None:
        credentials = {}

    # create all the users on which consul-related services will run
    for username in [CONSUL_OS_USERNAME]:
        utils.create_service_user(username, '/opt/consul',
                                  groups=[CONSUL_OS_USERNAME,
                                          utils.CLUSTER_OS_GROUP])
    if bootstrap_cluster:
        # starting the cluster - create all the certs, they're not there yet
        ca_crt, ca_key = ssl.create_ca_cert()
        server_cert, server_key = ssl.create_cert(
            ca_crt, ca_key, ip=host_ip,
            common_name='consul_{0}'.format(node_name))
        client_cert, client_key = ssl.create_cert(
            ca_crt, ca_key, ip=host_ip,
            common_name='consul_client_{0}'.format(node_name))

        shutil.move(server_cert, CONSUL_SERVER_CERT)
        shutil.move(server_key, CONSUL_SERVER_KEY)
        shutil.move(ca_crt, CONSUL_CA_CERT)
        shutil.move(ca_key, CONSUL_CA_KEY)
        shutil.move(client_cert, CONSUL_CLIENT_CERT)
        shutil.move(client_key, CONSUL_CLIENT_KEY)
        if not credentials.get('encryption_key'):
            credentials['encryption_key'] = utils.generate_encryption_key()
        node_status['encryption_key'] = credentials['encryption_key']
    else:
        for filename, key in [(CONSUL_SERVER_KEY, 'key'),
                              (CONSUL_SERVER_CERT, 'cert'),
                              (CONSUL_CLIENT_CERT, 'client_cert'),
                              (CONSUL_CLIENT_KEY, 'client_key'),
                              (CONSUL_CA_CERT, 'ca')]:
            with open(filename, 'w') as pem_file:
                pem_file.write(credentials[key])

    consul_service = Consul()
    owner = pwd.getpwnam(CONSUL_OS_USERNAME)
    os.chown('/opt/consul', owner.pw_uid, owner.pw_gid)
    consul_service.prepare_settings(node_name=node_name, host_ip=host_ip,
                                    bootstrap_cluster=bootstrap_cluster,
                                    credentials=credentials, **kwargs)
    os.chown(CONSUL_CONFIG_PATH, owner.pw_uid,
             grp.getgrnam(utils.CLUSTER_OS_GROUP).gr_gid)
    os.chmod(CONSUL_CONFIG_PATH, 0660)
    consul_service.configure()

    consul_watcher = ConsulWatcher()
    consul_watcher.configure()

    recovery_watcher = ConsulRecoveryWatcher()
    recovery_watcher.configure()


def start(node_name, host_ip, bootstrap_cluster=False, **kwargs):
    consul_service = Consul()
    consul_service.start()

    consul_watcher = ConsulWatcher()
    consul_watcher.start()

    # store the encryption key in KV so that it can be returned in a get_status
    # call
    client = get_consul_client()
    wait_until_consul_ready(client)

    recovery_watcher = ConsulRecoveryWatcher()
    recovery_watcher.start()
    logger.info('Consul server started')

    if bootstrap_cluster:
        # we're starting the cluster - store the CA key & cert, and the
        # encryption key in consul so that when a node needs to join, we can
        # generate a new cert for them using the same CA
        ssl.store_ca_cert(client, CONSUL_CA_CERT,
                          CONSUL_CA_KEY)

        # note: cas=0 means that the previous index needs to be 0, ie. the put
        # will only succeed if the key didn't exist at all
        client.kv.put('encryption_key', node_status['encryption_key'], cas=0)

    logger.debug('Putting current node details in consul KV: %s',
                 node_status['name'])

    write_config_file('heartbeat_check', {
        'checks': [
            {
                'id': 'consul_heartbeat_check',
                'name': 'consul_heartbeat_check',
                'status': 'passing',
                'ttl': '30s'
            }
        ]
    })

    checks = node_status['checks']
    checks.update({
        'heartbeat_check': 'consul_heartbeat_check',
    })
    node_status['checks'] = checks


def write_config_file(name, config):
    config_dir = os.path.dirname(CONSUL_CONFIG_PATH)
    filename = os.path.join(config_dir, '{0}.json'.format(name))

    # technically a race condition to check before use, but this code can't be
    # run concurrently. No 'x' open mode in python 2.
    if os.path.exists(filename):
        raise RuntimeError('Deploying consul config file: {0} already exists'
                           .format(filename))

    with open(filename, 'w') as f:
        json.dump(config, f, indent=4, sort_keys=True)


class ConsulHTTPClient(ConsulHTTPBase):
    # the default python-consul HTTPClient has no way to pass timeout to
    # it externally. We subclass it and reimplement all the HTTP methods
    # only to add the timeout parameter.
    def __init__(self, *args, **kwargs):
        cert = kwargs.pop('cert', None)
        self.timeout = kwargs.pop('timeout', 3)  # seconds
        super(ConsulHTTPClient, self).__init__(*args, **kwargs)
        self.session.verify = kwargs.get('verify')
        self.session.cert = cert

    def get(self, callback, path, params=None):
        uri = self.uri(path, params)
        return callback(self.response(
            self.session.get(uri, verify=self.verify, timeout=self.timeout)))

    def put(self, callback, path, params=None, data=''):
        uri = self.uri(path, params)
        return callback(self.response(
            self.session.put(uri, data=data, verify=self.verify,
                             timeout=self.timeout)))

    def delete(self, callback, path, params=None):
        uri = self.uri(path, params)
        return callback(self.response(
            self.session.delete(uri, verify=self.verify,
                                timeout=self.timeout)))

    def post(self, callback, path, params=None, data=''):
        uri = self.uri(path, params)
        return callback(self.response(
            self.session.post(uri, data=data, verify=self.verify,
                              timeout=self.timeout)))


class ConsulClient(ConsulClientBase):
    def __init__(self, *args, **kwargs):
        self.timeout = kwargs.pop('timeout', 3)  # seconds
        self.cert = kwargs.pop('cert', None)
        super(ConsulClient, self).__init__(*args, **kwargs)

    def connect(self, host, port, scheme, verify=True):
        return ConsulHTTPClient(host, port, scheme, verify,
                                timeout=self.timeout, cert=self.cert)


def get_consul_client(host='localhost', **kwargs):
    """Create a Consul client connected to localhost by default."""
    if kwargs.get('verify', True) and 'cert' not in kwargs:
        kwargs['verify'] = CONSUL_CA_CERT
        kwargs['cert'] = (
            CONSUL_CLIENT_CERT,
            CONSUL_CLIENT_KEY
        )
    kwargs.setdefault('scheme', 'https')
    return ConsulClient(host=host, **kwargs)


def wait_until_consul_ready(client=None, retries=15, retry_delay=3):
    if client is None:
        client = get_consul_client()
    logger.debug('Waiting for consul to start...')
    for retry_num in range(retries):
        try:
            leader = client.status.leader()
            if leader:
                logger.debug('Consul cluster ready! Leader is %r', leader)
                return client
            logger.debug('Consul has not finished election yet, waiting '
                         '%d seconds...', retry_delay)
        except requests.exceptions.RequestException as e:
            logger.debug('Consul not started yet, waiting %d seconds...',
                         retry_delay)
        except ConsulException as e:
            if e.args and 'No cluster leader' in e.args[0]:
                logger.debug('Consul has not finished election yet, waiting '
                             '%d seconds...', retry_delay)
            else:
                raise
        time.sleep(retry_delay)
    # we've retried as many times as we could. If the cluster isn't ready yet,
    # at this point it's an error.
    leader = client.status.leader()
    if not leader:
        raise RuntimeError('No consul leader after {0} retries'
                           .format(retries))
